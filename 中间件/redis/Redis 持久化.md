### RDB 持久化
#### RDB 文件的创建和载入
- 创建
	- SAVE
		- 直接阻塞服务进程，直至 RDB 文件创建完毕为止
		- 客户端所有命令阻塞
	- BGSAVE
		- 派生一个子线程，fork 主线程
- 载入
	- 服务器自动执行
		- 如果开启 AOF 功能，优先使用 AOF文件
		- AOF 关闭，才会使用 RDB
		- 载入时，服务器会处于阻塞状态


#### 自动定期执行
- 服务器在 900 秒内，至少1次修改
- 服务器在 300 秒内，至少10次修改
- 服务器在 60 秒内，至少10000次修改

#### dirty 计数器 lastsave
- 记录距离上次 save 或 BGSAVE 之后的数据库状态（多少次修改操作）
- lastsave 记录上一次成功执行 save 命令

#### 检查保存条件
- 100 ms 执行一次
- dirty 数量大于设置的参数
- 且距离上次保存的时间超过条件所设置的时间

#### RDB 文件结构
|REDIS|db_version|databases|EOF|check_sum|
|-|-|-|-|-|

- REDIS：快速检查所载入的是否为 RDB 文件
- databases：部分包含着零个或任一多个数据库
- EOF：长度1个字节，标志正文内容结束
- check_num：8个字节长的无符号整数

#### 增量快照
做了一次全量快照后，后续的快照只对修改的数据进行快照记录，这样可以避免每次全量快照的开销。
需要额外的空间开销，记录那些数据被改了

### AOF 持久化
- AOF 保存的是 Redis 的写命令
- 除了 SELECT 命令是服务器自动那个添加的之外，其他都是来自于客户端

#### 实现
- 执行一个写命令，将写命令最佳到 aof_buf buffer 末尾

#### aof_buf 刷新
- appendfsync
	- always：将 aof_buf 所有内容写入并同步 AOF 文件
		- 效率低
		- 最安全
	- everysec：将 aof_buf 写AOF 文件，如果上次同步 AOF 文件时间超过了1秒钟，再次同步 AOF 文件
	- no：将 aof_buf 写AOF 文件，不同步。由操作系统决定何时同步
		- 写入速度最快
		- 但是不安全



> 文件的写入和同步
> 现代操作系统，用户调用 write 函数，写入数据暂时保存在内存缓冲中，等缓冲区满了或超过时限后，才真正的将缓冲区数据写入磁盘

#### AOF 文件的载入和数据还原
- 创建一个不带网络连接的伪客户端，用于执行 Redis 的命令
- 从 AOD 文件中分析并读取出一条命令
- 使用伪客户端执行命令
- 重复执行

#### AOF 重写
- AOF 随着操作变多会越来越大
- Redis 会创建一个新的 AOF 文件替代现有的 AOF、
- 压缩或合并原有 AOF 文件的命令，只保存当前数据库状态的命令。

#### AOF 后台重写
- AOF 重写会占用大量线程时间进行写入操作
- 子进程 AOF 重写期间，服务器进程可以处理命令请求 （fork）
- 子进程带有服务器进程的数据副本，使用子进程而不是线程，避免使用锁
- 子进程 AOF 重写的时候，服务器继续处理命令，为了解决数据不一致，设置了 AOF 缓冲区
- 缓冲区在服务器创建子进程之后使用
- 服务器写命令后，同时奖这个命令发送给 AOF 缓冲区 和 AOF 重写缓冲区

![](https://mynoteimage.oss-cn-beijing.aliyuncs.com/note/2022-03-12-135925.png)


- 子进程完成 AOF 重写后，给父进程发送信号
- AOF 重写缓冲区的所有内容写入到新AOF 文件，此时 AOF 文件和服务区当前数据库状态一致
- 对新 AOF 文件改名，原子地覆盖现有 AOF 文件，完成替换

> Redis 4.0 后，可以混合使用 AOF 日志和内存快照
> AOF 只记录快照间的操作，等到第二次全量快照，可以清空 AOF日志 