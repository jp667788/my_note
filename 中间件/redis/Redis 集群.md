### 数据分布

#### 数据分区规则
Redis Cluster 采用**哈希分区**

1. 节点取余分区

	使用特定数据，如 Redis 的键或用户的 ID，根据节点数量 N 使用公式：hash(key) % N 计算出哈希值
	
	- 优点：简单
	- 问题：节点数量变化时，数据节点映射关系需要重新计算，导致数据重新迁移


2. 一致性哈希分区

	每个节点分配一个 token，一般在 0~2^32，构成一个哈希环。读写时，根据 key 进行 hash 计算，在 hash 环中找到第一个大于等于该 hash 值的 token 节点。
	
	- 优点：加减节点只影响相邻的节点
	- 缺点：
		- 加减节点会造成 hash 环中部分数据无法命中
		- 节点数量较少时，节点变化会大范围影像数据
		- 普通 hash 一致性算法增减节点时，需要增加一倍或减去一倍节点才能保证数据和负载的均衡
		- 减去节点会使得相邻的下个节点压力增大

3. 虚拟槽分区

	虚拟槽分区使用分散度良好的 hash 函数把所有的数据映射到一个固定范围的整数集合中，整数定义为**槽**。一般槽数量要远大于节点数。槽是节点内数据管理和迁移的基本单位，每个节点会负责一定数量的槽。
	
	![](https://mynoteimage.oss-cn-beijing.aliyuncs.com/note/2022-03-16-160701.png)
	
### Redis 数据分区
**Redis 采用虚拟槽分区**，所有的键根据 hash 函数映射到 0 ~ 16383 整数槽内，每个节点维护一部分的槽。

- 解耦了数据和节点之间的关系，简化了扩容、缩容的难度
- 节点自身维护了槽和节点之间的映射关系
- 支持节点、槽、建之间的映射查询


### 集群伸缩
#### 扩容集群
1. 准备新节点
	
	提前准备好新节点并运行在集群模式下，新节点建议跟集群内的节 点配置保持一致，便于管理统一。
	``` 
	redis-server conf/redis-6386.conf
	```
	启动后的新节点作为孤儿节点运行，并没有其他节点与之通信
	
2. 加入集群
	
	 新节点采用 cluster meet 命令加入集群
	 ```
	 cluster meet 127.0.0.1 6386
	 ```
	 
	 进过一段时间的 ping/pong 通信后，新节点被其他节点发现，并保存到本地。
	 新节点初始为主节点状态，但是没有分配槽，无法进行读写。
	 
 3. 迁移槽和数据
	1. 槽迁移计划
		
		首先需要为新节点制定迁移计划，确定迁移的槽和数据，并保证各个节点数据均匀。
		
	2. 槽数据迁移

		数据迁移是逐个槽进行的
		1. 对目标节点发送 cluster setslot{slot}importing{sourceNodeId} 命令，让目标节点准备导入数据
		2. 对源节点发送 cluster setslot{slot}migrating{targetNodeId}，让源目标节点准备导出
		3. 源节点循环执行 cluster getkeysinslot{slot}{count}，获取指定 count 的键
		4. 源节点执行 migrate{targetIp}{targetPort}""0{timeout}keys{keys...} 命令，通过 pipeline 机制将获取的键值批量迁移到目标节点（Redis 3.0.6之前只能单个建迁移）
		5. 重复 3 4 直到槽下所有的键值数据
		6. 向集群内所有主节点发送 cluster setslot{slot}node{targetNodeId} 命令，通知槽已分配目标节点。遍历所有主节点，发送通知。 

	3. 添加从节点
			cluster replicate{masterNodeId} 命令主节点添加对应从节点 
			此过程基于扩容时同时添加多个节点
			
#### 收缩集群
1. 确定节点是否有槽，如果有需要迁移槽和数据
2. 当下线节点已没有槽或是从节点，通知所有集群移除该节点信息后，完成下线

### 请求路由
Redis集群对客户端通信协议做了比较大的修改， 为了追求性能最大化，并没有采用代理的方式而是采用**客户端直连节点的方式**。
> 所以单机切换到集群时，需要更改客户端代码

#### 请求重定向
集群模式下，节点收到命令时：
- 算建对应的槽
- 再根据槽找出对应的节点
	- 如果是自身节点，则处理请求
	- 否则返回 MOVED 重定向错误，通知客户端请求正确的节点

重定向信息中包含了：
- 键所对应的槽
- 以及负责槽的节点地址

> 节点对于不属于它处理的命令只会返回重定向响应，不会转发


#### 键命令执行步骤
1. 计算槽

	根据 key 使用 CRC16 算法计算一个 16bit 的值，再对 16384 取模	
	
2. 槽节点查找

	集群内每个节点都会知道所有节点的槽信息，就可以定位槽所在的节点
	

#### Smart 客户端
大多数开发语言的Redis客户端都采用Smart客户端支持集群协议，客户 端如何选择见：http://redis.io/clients，

内部维护一个 Slot - node 的映射关系，本地就可实现查找节点。 MOVED 命令用来更新这个映射关系

键命令执行步骤：
1. 计算 slot 并通过本地缓存获取节点信息，发送命令
2. 连接错误则随机连接节点，重新执行命令。redirections参数减1。
3. 捕获到 MOVED 重定向错误，更新本地缓存
4. 重复1-3步骤，直至成功或redirections == 0

#### ASK 重定向
##### 客户端 ASK 重定向
在 Redis Cluster 进行 槽迁移时，当 slot 对应的数据从源节点到目标节点的迁移过程中，客户端需要识别，保证建命令可正常执行。

出现上述情况，客户端键执行命令步骤将发生变化：

1. 客户端根据本地缓存发送命令给源节点，如果存在键对象则直接返回客户端
2. 如果键不存在，则可能存在于目标节点，此时源节点返回 ASK **重定向异常**：（error）ASK{slot}{targetIP}：{targetPort}
3. 客户端从 ASK 重定向异常中提取出目标节点信息，发送 asking 命令到目标节点，打开客户端链接标识，再执行键命令。存在返回，不存在返回不存在

![](https://mynoteimage.oss-cn-beijing.aliyuncs.com/note/2022-03-17-034623.png)

![](https://mynoteimage.oss-cn-beijing.aliyuncs.com/note/2022-03-17-034646.png)


> ASK 不会使客户端本地slot缓存更新

##### 节点内部处理
- 如果键所在的槽由当前节点负责，键不存在则查找 migrating_slots_to  数组查看该键是否正在迁移，如果是返回 ASK 重定向
- 如果客户端发送 asking 命令打开了 CLIENT_ASKING 标识，则客户端西祠发送键命令查找 importing_slots_from 数组获取 节点，如果指向自身就执行命令

asking 是一次性命令，每次执行完后，客户端标识都会修改回原状态，每次客户端收到 ASK 重定向都需要发送 asking 命令


### 故障转移
#### 故障发现
故障通过消息传播机制实现

- 主观下线：指某个节点认为另一个节点不可用，即下线状态。不能作为最终的故障判定，可能出现误判。
- 客观下线：指标记一个节点真正下线，集群内节点达成共识，任务此节点下线。

##### 主观下线
集群中每个节点定期向其他节点发送 ping 消息，接受节点回复 pong 作为响应。如果在cluster-node-timeout 时间内一直失败，则发送节点认为接收节点发生故障，标记为主观下线（pfail）

![](https://mynoteimage.oss-cn-beijing.aliyuncs.com/note/2022-03-17-040321.png)

##### 客观下线
当某个节点判断另一个节点主观下线后，相应的节点状态会跟随消息在集群内传播。

当接受节点发送消息体中含有主观下线的节点状态时，在本地找到节点的 clusterNode 结构，会保存到下线报告链表。

通过消息传播，**当半数以上持有槽的主节点**都标记某个节点主观下线时，触发客观下线。

