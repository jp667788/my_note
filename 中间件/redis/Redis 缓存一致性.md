### 缓存一致性问题

![](https://mynoteimage.oss-cn-beijing.aliyuncs.com/note/2022-04-19-143316.jpg)

方案：
1. 先更新缓存，后更新数据库
2. 先更新数据库，后更新缓存

无论谁先谁后，但凡后者发生异常，就会对业务造成影响

### 并发引起的一致性问题
1.  线程 A 更新数据库（X = 1）
2.  线程 B 更新数据库（X = 2）
3.  线程 B 更新缓存（X = 2）
4.  线程 A 更新缓存（X = 1）

- 最终 X 的值在缓存中是 1，在数据库中是 2，发生不一致。
- 每次数据发生变更，都「无脑」更新缓存，但是缓存中的数据不一定会被「马上读取」，这就会导致缓存中可能存放了很多不常访问的数据，浪费缓存资源。

### 删除缓存可以保证一致性吗

1. **先删除缓存，后更新数据库**
	1.  线程 A 要更新 X = 2（原值 X = 1）

	2.  线程 A 先删除缓存

	3.  线程 B 读缓存，发现不存在，从数据库中读取到旧值（X = 1）

	4.  线程 A 将新值写入数据库（X = 2）

	1.  线程 B 将旧值写入缓存（X = 1）

最终 X 的值在缓存中是 1（旧值），在数据库中是 2（新值），发生不一致。

2. **先更新数据库，后删除缓存**

	1.  缓存中 X 不存在（数据库 X = 1）

	2.  线程 A 读取数据库，得到旧值（X = 1）

	3.  线程 B 更新数据库（X = 2)

	4.  线程 B 删除缓存

	5.  线程 A 将旧值写入缓存（X = 1）

最终 X 的值在缓存中是 1（旧值），在数据库中是 2（新值），也发生不一致。

这种情况必须满足 3 个条件：

1.  缓存刚好已失效
    
2.  读请求 + 写请求并发
    
3.  更新数据库 + 删除缓存的时间（步骤 3-4），要比读数据库 + 写缓存时间短（步骤 2 和 5）

**条件 3 发生的概率其实是非常低**，但是依然有第二步失败时导致的数据不一致问题

### 如何保证两步都成功
- 重试
	- 立即重试很大概率「还会失败」
	- 「重试次数」设置多少才合理？
	- 重试会一直「占用」这个线程资源，无法服务其它客户端请求
- 异步重试
	- 把重试请求写到「消息队列」中，然后由专门的消费者来重试，直到成功
		- **订阅数据库变更日志，再操作缓存**。


![](https://mynoteimage.oss-cn-beijing.aliyuncs.com/note/2022-04-19-150527.jpg)

### 主从库延迟和延迟双删问题
在「先更新数据库，再删除缓存」方案下，「读写分离 + 主从库延迟」也会导致不一致：
1.  线程 A 更新主库 X = 2（原值 X = 1）
2.  线程 A 删除缓存
3.  线程 B 查询缓存，没有命中，查询「从库」得到旧值（从库 X = 1）
4.  从库「同步」完成（主从库 X = 2）
5.  线程 B 将「旧值」写入缓存（X = 1）

最终 X 的值在缓存中是 1（旧值），在主从库中是 2（新值），也发生不一致。

最有效的办法就是，**把缓存删掉**。

### 延时双删
- 在线程 A 删除缓存、更新完数据库之后，先「休眠一会」，再「删除」一次缓存
- 线程 A 可以生成一条「延时消息」，写到消息队列中，消费者延时「删除」缓存