# 线程池

## 优点
- 减少在创建和销毁线程时的时间以及系统资源的消耗
- 提高响应速度，任务可以不需要等到线程创建就能立即执行
- 提高线程的可管理性，线程池统一分配、调优、监控

## 总体架构
### 运行流程
![](https://mynoteimage.oss-cn-beijing.aliyuncs.com/note/2021-09-19-092635.jpg)

### 类关系
![](https://mynoteimage.oss-cn-beijing.aliyuncs.com/note/2021-09-19-051728.png)

- **Executor** : 定义线程池最基本的操作：执行任务

``` java
public interface Executor {  
   void execute(Runnable command);  
}
```

- **ExecutorService**：定义线程池必须提供管理线程的方法。将任务提交和任务执行进行解耦
- **AbstractExecutorService**：实现了 ExecutorService 的普通线程池
- **ScheduledExecutorService** ：定时任务线程池。

## 创建线程池方式
- 直接调用 ThreadPoolExecutor 构造参数 （推荐）
- 调用 Executors 提供的方法
	- newFixedThreadPool()
		- 核心线程数 = 最大线程数
		- 队列大小 Integer.MAX_VALUE (相当于无限)
	- newCachedThreadPool()
		- 核心线程0，最大线程 Integer.MAX_VALUE (相当于无限)
		- 队列使用 SynchronousQueue 传递
		- 来一个任务创建一个新的线程
	- newSingleThreadPool()
		- 核心线程数 = 最大线程数 = 1
		- 队列大小 Integer.MAX_VALUE (相当于无限)
		- 始终一个线程在执行

## 生命周期管理
线程池的运行状态，是伴随线程池的运行，内部自己维护的。

```java
private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
```

ctl 变量包含两个信息：
- 高3位保存状态信息：runState
- 低29位保存有效线程数量：workerCount

用一个变量去存储两个值，可避免在做相关决策时，出现不一致的情况，不必为了维护两者的一致，而占用锁资源

### 运行状态
ThreadPoolExcutor 一共有五种运行状态：
- RUNING
	- 接受新任务
- SHUTDOWN
	- 关闭状态，不接受新任务，但队列中的任务会执行完
- STOP
	- 不接受新任务，也不处理队列中任务，正在执行的任务终止
- TIDYING
	- 所有的任务都终止了，workerCount = 0
- TERMINAED
	- terminated() 方法执行完毕，进入该状态

- ![](https://mynoteimage.oss-cn-beijing.aliyuncs.com/note/2021-09-04-644.png)


## 核心参数
- corePoolSize：核心线程数
- maximumPoolSize：最大线程数
- workQueue：工作队列
- threadFactory：创建线程的工厂，比如给线程加上前缀
- handler：拒绝任务处理器
- keepAliveTime：线程在线程池中不被销毁的空闲时间
- allowCoreThreadTimeOut：允许核心线程超时销毁，调用 allowCoreThreadTimeOut（true）方法，可以使 allowCoreThreadTimeOut = true

## 执行流程
![](https://mynoteimage.oss-cn-beijing.aliyuncs.com/note/2021-09-19-063632.png)

### 任务调度 execute 方法
``` java
public void execute(Runnable command) {
    if (command == null)
        throw new NullPointerException();
    int c = ctl.get();
	// 判断线程数是否小于核心线程数
    if (workerCountOf(c) < corePoolSize) {
		// 添加核心线程
        if (addWorker(command, true))
            return;
        c = ctl.get();
    }
	// 大于核心线程数放入队列
    if (isRunning(c) && workQueue.offer(command)) {
        int recheck = ctl.get();
        if (! isRunning(recheck) && remove(command))
            reject(command);
        else if (workerCountOf(recheck) == 0)
            addWorker(null, false);
    }
	// 队列满了，创建新的非核心线程
    else if (!addWorker(command, false))
		// 达到最大线程数，执行拒绝策略
        reject(command);
}
```

### 任务缓冲
线程池中是以生产者消费者模式，通过一个阻塞队列来实现的。阻塞队列缓存任务，工作线程从阻塞队列中获取任务。
在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用
![](https://mynoteimage.oss-cn-beijing.aliyuncs.com/note/2021-09-19-081430.jpg)

### 任务申请 getTask()

``` java
	private Runnable getTask() {
		// 上一个获取任务是否超时
		boolean timedOut = false; // Did the last poll() time out?

		for (;;) {
			int c = ctl.get();
			int rs = runStateOf(c);

			// Check if queue empty only if necessary.
			// 检查线程池状态
			if (rs >= SHUTDOWN && (rs >= STOP || workQueue.isEmpty())) {
				decrementWorkerCount();
				return null;
			}

			int wc = workerCountOf(c);

			// Are workers subject to culling?
			// 判断核心线程是否允许超时 或 线程数是否超过核心线程数
			boolean timed = allowCoreThreadTimeOut || wc > corePoolSize;
			
			// 检查线程数是否超过最大线程数 或 线程获取任务超时 
			if ((wc > maximumPoolSize || (timed && timedOut))
				&& (wc > 1 || workQueue.isEmpty())) {
				if (compareAndDecrementWorkerCount(c))
					return null;
				continue;
			}

			try {
				// 获取任务
				Runnable r = timed ?
					workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :
					workQueue.take();
				if (r != null)
					return r;
				// 获取任务超时
				timedOut = true;
			} catch (InterruptedException retry) {
				timedOut = false;
			}
		}
	}
```

![](https://mynoteimage.oss-cn-beijing.aliyuncs.com/note/2021-09-19-082313.png)

### 任务拒绝
JDK 提供了 RejectExecutionHanlder 接口，实现拒绝策略。

JDK 默认提供4中拒绝策略：
- AbortPolicy：抛出异常 RejectedExecutionException
- DiscardPolicy：直接丢弃任务，不做任何处理
- DiscardOldestPolicy：丢弃最早进入队列的任务，再把新任务加到工作队列
- CallerRunsPolicy：由提价任务的线程执行


## Worker 线程
线程池中的工作线程被封装成了 Worker 对象

``` java
private final class Worker extends AbstractQueuedSynchronizer implements Runnable{ 
	final Thread thread;//Worker持有的线程 
	Runnable firstTask;//初始化的任务，可以为null 
}
```

Worker **实现了 Runnable 接口**，并持有一个 Thread，和一个初始化的任务 firstTask。

- firstTask 不为 null，创建线程，直接执行firstTask，即核心线程的创建。
- firstTask 为 null，创建线程执行队列中的 task，即非核心线程的创建

![](![[Pasted image 20210919163545.png]])

### worker 线程管理
ThreadPoolExcutor 通过 一个 HashMap 存放 已经创建worker，这样可以通过 put、remove 的操作，来管理 Worker 线程。

Worker是通过继承 [[AbstractQueuedSynchronizer]]，使用AQS来实现独占锁这个功能，是为了实现不可重入的特性。
s
Woker线程在空闲的时候，可能会被回收：
- 当 lock 方法获取到锁后，表明这个线程正在执行任务
- 当前线程没有持有独占锁，表明是空闲的
- 线程池在执行shutdown方法或tryTerminate方法时会调用interruptIdleWorkers方法来中断空闲的线程，interruptIdleWorkers方法会使用tryLock方法来判断线程池中的线程是否是空闲状态；如果线程是空闲状态则可以安全回收。
![](https://mynoteimage.oss-cn-beijing.aliyuncs.com/note/2021-09-19-085257.png)


### worker 线程添加
addWorker(Runnable firstTask,  boolean core) 方法实现 worker 线程的添加，并运行。

- firstTask：可以为空，用于指定新增的线程执行的第一个任务。
- core：是否创建的是核心线程（wc < coolPoolSize）

![](https://mynoteimage.oss-cn-beijing.aliyuncs.com/note/2021-09-19-090710.png)

### Worker 线程回收
线程池当不持有 worker 的引用时，worker 将被 JVM 自动回收。
worker 在创建后，会一直轮询获取任务。
当线程获取任务超时时，worker 会通过 **processWorkerExit** 方法消除和 线程池间的引用。

```java
try { while (task != null || (task = getTask()) != null) { //执行任务 } 
} finally { processWorkerExit(w, completedAbruptly);
		   //获取不到任务时，主动回收自己 
}
```

![](https://mynoteimage.oss-cn-beijing.aliyuncs.com/note/2021-09-19-091808.png)

### 线程执行任务
Worker 通过 runWorker 来执行任务：

1. while循环不断地通过getTask()方法获取任务。 
2. getTask()方法从阻塞队列中取任务。 
3. 如果线程池正在停止，那么要保证当前线程是中断状态，否则要保证当前线程不是中断状态。 
4. 执行任务。 
5. 如果getTask结果为null则跳出循环，执行processWorkerExit()方法，销毁线程。

![](https://mynoteimage.oss-cn-beijing.aliyuncs.com/note/2021-09-19-092011.png)


## 线程池参数配置
### 参数合理配置
- CPU 密集型
	- 线程数 = CPU核数 + 1
	- 当线程因为偶尔的内存页失效或其他原因导致阻塞时，这个额外的线程可以顶上，从而保证 CPU 的利用率
- IO  密集型
	- CPU 核数 * [ 1 +（I/O 耗时 / CPU 耗时）]

### 线程池参数动态化

![](https://mynoteimage.oss-cn-beijing.aliyuncs.com/note/2021-09-19-092151.png)

- **动态调参**：支持线程池参数动态调整、界面化操作；包括修改线程池核心大小、最大核心大小、队列长度等；参数修改后及时生效
- **任务监控**：支持应用粒度、线程池粒度、任务粒度的Transaction监控
- **负载告警**：线程池队列任务积压到一定值的时候会）告知应用开发负责人；当线程池负载数达到一定阈值的时候会告知应用开发负责人


#### 参数动态化
JDK原生线程池ThreadPoolExecutor提供了如下几个public的setter方法，如下图所示：
![](https://mynoteimage.oss-cn-beijing.aliyuncs.com/note/2021-09-19-092348.jpg)

#### 运行时状态实时查看
用户基于JDK原生线程池ThreadPoolExecutor提供的几个public的getter方法，可以读取到当前线程池的运行状态以及参数，如下图所示：
![](https://mynoteimage.oss-cn-beijing.aliyuncs.com/note/2021-09-19-092450.jpg)


ScheduledThreadPoolExecutor ？？？