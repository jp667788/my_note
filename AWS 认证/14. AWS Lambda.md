x
# Serverless 

- 当使用无服务器服务时，不必再管理服务器
- 只需要部署代码


# Lambda 

- 云上的虚拟服务
- 受到要配置的内存和CPU数量的限制
- 持续运行
- 自动扩展


- 是一个虚拟函数：不需要管理服务器
- 只需提供代码和运行函数｡
- 快速运行
- 只有运行函数时，才会计费
- 自动扩展


## 优点

- 定价简单
	- 基于请求数､ 调用数以及你的计算机时间付费
	- 100万个Lambda请求和400 000 GB秒的计算时间的免费额度
- 可以非常轻松地与CloudWatch进行监控集成
- 支持多种编程语言
- 可以为每个功能配置多达10GB的RAM

## 支持的语言

- Node js
- Python
- Java
- C# .Net
- Golang
- Ruby
- 自定义运行时API

- 容器
	- 如果需要再Lambda 上运行容器，需要该容器实现了Lambda运行时API


## 同步调用

- 使用CLI､ SDK､ API网关甚至应用负载平衡器时,
- 返回的任何错误都必须在客户端处理


### 调用方

- 服务
	- ELB
	- GateWay
	- CloudFont

## 集成 ALB

- 如果你想把它们公开到互联网上, 你想让人们通过HTTP或者HTTPS端点来使用它们.
- 客户端将调用并以HTTP或HTTPS的形式向ALB发送请求, ALB将同步调用目标组中的lambda函数
- 从ALB到lambda, HTTP被转换为JSON文档

- Lambda 的响应
	- 状态码、状态描述
	- 响应头（键/值对）
	- body 
	- 是否 base64 加密标识

### ALB 请求头多参数

- ALB 支持请求投中，多个同名的参数
- 如：https://exapmle.com/path?name=foo&name=bar
	- 将看到name, 而不是一个值, 我将看到一个值数组
	- "queryStringParameters":{"name":["foo","bar"]}

## 异步调用 

- 如调用 Amazon S3､ SNS主题､ CloudWatch事件
- 如果调用出现问题，Lambda 会重试3次
	- 立即重试
	- 第一次后 1 min
	- 第二次后 2 min
- lambda 函数幂等性
- 可以定义一个 DLQ  死信队列

### 调用方

- 服务
	- S3 事件通知
	- SNS
	- CloudWatch Events或CloudWatch EventBridge,
-

### 集成 CloudWatch Events或CloudWatch EventBridge‘

- 执行无服务器CRON或速率
	- 创建一个EventBridge规则, 然后每隔一个小时触发 Lambda
- 创建一个CodePipeline EventBridge Rule

### 集成 S3事件通知

- 在创建､ 删除､ 恢复对象时以及在发生复制时获得通知
- 可以按前缀和后缀进行筛选
- 如果您希望确保不会丢失任何事件通知, 请确保在存储桶上启用版本控制


## 事件源映射

- 适用于Kinesis数据流､ SQS和SQS FIFO队列以及DynamoDB数据流
- Lambda需要请求服务获取一些记录, 然后将返回这些记录
- 轮询请求服务

- 两类源映射器
	- 流
		- 用于Kinesis数据流和DynamoDB流
		- 会为每个碎片创建一个迭代器,
		- 可以从碎片的开头或特定时间戳开始读取
		- 适合低流量或高流量情况
			- 低流量时：处理之前使用批处理窗口来累积记录
			- 高流量时：可以设置Lambda在分片级别并行处理多个批处理
				- 对于每个批次, 它们将在分区键级别按顺序处理
				- 默认情况下, 如果函数返回错误, 则将重新处理整个批处理
					- 为了确保按顺序处理, 受影响的批处理将暂停, 直到错误得到解决
						- 可以将事件源映射配置为第一个， 即丢弃旧事件｡
						- 或者限制重试次数,
						- 或者在出现错误时拆分批
					- 如果超时，可以丢弃到指定目标中
	- 队列
		- SQS和SQS FIFO
			- Lambda事件源映射轮询
			- 事件源映射将使用长轮询来轮询SQS
			- 可以指定批处理大小
			- 将队列可见性超时设置为Lambda函数超时的六倍
			- 如果需要设置死信队列，要在  SQS 中设置
				- Lambda的DLQ只适用于异步调用｡
			- 为了处理队列而进行扩展的Lambda函数的数量将等于活动消息组的数量


### 伸缩

- 对于Kinesis数据流和DynamoDB流, 每个流碎片都有一个Lambda调用
	- 如果使用并行化, 则每个分片最多可以同时处理10个批次
- 对于SQS
	- 它每分钟增加16个以上的实例以进行纵向扩展
	- 每秒同时处理的最大批处理量为1000
	- 并且Lambda函数将按比例增加到活动消息组的数量


## Event 和 Context 对象


- 由EventBridge规则调用
- 接下来EventBridge会创建一个事件
- 这个事件会被传递给Lambda函数, Lambda函数会接收到这个事件, 它被称为事件对象

![](https://mynoteimage.oss-cn-beijing.aliyuncs.com/2023-05-22-132807.png)



### Event 对象

- JSON 
- 包含函数将要处理的数据
- lambda 转换成运行时数据

### Context 对象

- 提供有关调用本身和运行时环境的数据的方法
- 运行时被传递给Lambda函数
- 可以得到AWS请求ID、函数名, 内存限制, 等等


## 目标

- 当我们执行异步调用或事件映射器时，我们很难看到它是失败还是成功
- 可以将失败或成功定义为一个事件发送到指定的目标
	- 异步调用，可以发送到
		- SQS､ SNS､Lambda和Amazon EventBridge总线的目标
		- DLQ 虽然也能做到，但是只能处理 SQS SNS 
	- 事件源映射
		- SQS､ SNS
		- 将丢弃的事件批次发送到失败的事件目的地



## 权限 

- Lambda的一些简单托管策略
	- BasicExecutionRole, 它允许我们将日志上传到CloudWatch
	- KinesisExecutionRole用于从Kinesis中读取
	- DynamoDBExecutionRole用于从DynamoDB流中读取
- 最佳实践
	- 为每个函数创建一个Lambda执行角色
- 可以设置基于自愿的策略，


## 环境变量

- 字符串形式的键值对
- 可以加密这些环境变量, 例如, 通过KMS来存储秘密值


## 日志

- 所有Lambda执行日志都自动存储在CloudWatch日志中
- 提供有关调用､持续时间､ 并发执行､ 错误计数､成功率､ 限制､ 异步传递失败的信息

### X-Ray

- 只需在Lambda配置中启用它, 这称为主动跟踪
- 唯一需要做的是在代码中使用x射线SDK
- 三个环境变量
	- **\_X_AMZN_TRACE_ID**: contains the tracing header
	- **AWS_XRAY_CONTEXT_MISSING**: by default, LOG_ERROR
	- **AWS_XRAY_DAEMON_ADDRESS**: the X-Ray Daemon IP_ADDRESS:PORT


## 自定义边缘函数

- 使用CloudFront等工具时, 我们会让边缘位置分发内容
- 有时候，应用程序需要在到达应用程序本身之前在边缘执行某种形式的逻辑

- 两种边缘函数
	- CloudFront函数
		- 是用JavaScript编写的轻量级函数
		- 可修改查看器请求和响应
			- Viewer Request 查看请求：在 CloudFont 收到请求之后
			- Viewer Response 查看响应：在 CloudFont 转发响应之前
		- 用于对延迟敏感的大规模CDN定制
		- 提供亚毫秒级启动时间和每秒数百万次请求的规模｡
	- Lambda@Edge
		- 网站安全和隐私
		- 搜索引擎优化､ SEO
		- 跨源和数据中心的智能路由､ 边缘的僵尸网络缓解､ 边缘的实时图像转换､A/B测试､ 用户身份验证和授权､用户优先级划分､ 用户跟踪和分析
		- NodeJS或Python中函数
		- 可以扩展到每秒1000个请求
		- 修改查看器请求和相应
			- Viewer Request 查看请求：在 CloudFont 收到请求之后
			- Origin Request 源请求：在 CloudFont 转发请求之前
			- Origin Response 源响应：在 CloudFont 收到响应之后
			- Viewer Response 查看响应：在 CloudFont 转发响应之前
		- 在一个区域中创建一个边缘函数，CloudFont 会自动复制到其所有位置

![](https://mynoteimage.oss-cn-beijing.aliyuncs.com/2023-05-22-144217.png)



- CloundFont 函数执行时间在 1 ms 以内
	- 用于在请求或响应中插入
	- 修改或删除HTTP标头
	- 执行URL重写或重定向
	- 请求授权以创建和验证JWT标记
- Lambda@Edge 执行时间在 5-10 s
	- CPU和内存可调
	- 可以加载大量库 SDK
	- 可以通过网络访问用于处理数据的外部服务


## 默认 Lambda 

- 默认情况下，Lambda函数在您自己的VPC之外启动, 所以它在AWS拥有的另一个VPC中启动
	- 无法访问自己的 VPC

###  VPC 中使用 Lambda

- 需要定义VPC ID､ 子网, 并且需要为Lambda函数分配一个安全组
- 在子网中创建 ENI (Elastic Network Interface)
- Lambda函数需要一个Lambda VPC访问执行角色
- 公共子网中部署Lambda函数并不会为它提供Internet访问或公共IP


## Lambda 性能

- RAM
	- 可以以1兆字节的增量扩展到10千兆字节的RAM
	- 必须增加RAM以隐式地获得更多的vCPU
	- 当满扩展到 1792 MB 时，获得了一个完整的 vCPU
- 超时
	- 默认 3 s 超时
	- 时设置为最大900秒 = 15分钟
	- 超过15分钟，不是合格的 Lamda 用例，此时考虑 EC2，Fargate 

## Lambda 执行上下文

- 它是一个临时的运行时环境
- 用于初始化lambda代码的任何外部依赖项
- 多次调用 lambda ，Context 可以被重用
- 通过初始化，在后续调用中，避免重复执行，提高性能
- /tmp 存放编写的临时文件


## Layers 层

- 创建自定义运行环境
	- 支持 Lambda 本身不支持的语言
- 外部化依赖项的重用

## 文件系统 

- 如果Lambda函数在VPC中运行，可以访问EFS文件系统
	- 只需要配置Lambda，在初始化期间将EFS文件系统挂载到本地目录

![](https://mynoteimage.oss-cn-beijing.aliyuncs.com/2023-05-22-151839.png)



## 并发与吞吐

- 调用Lambda函数越多, Lambda函数的并发执行就越多
- 因为Lambda可以非常､ 非常容易和快速地扩展
- 可以限制Lambda函数可以并发执行的次数，进行节流
	- 在函数级别，设置“保留并发” reserve concurrency
		- 用来限制 Lambda 的最高并发量
	- 节流错误
		- 同步调用：函数返回  code 429
		- 异步调用：重试后，加入 DLQ

## 冷启动、预配置并发

- 冷启动
	- 意味着当你创建一个新的Lambda函数实例时, 你的代码必须被加载, 你的代码必须在处理程序之外运行
	- 意味着新实例处理的第一个请求的延迟比其他请求高
- 预配置并发
	- 在调用函数之前就分配了并发
	- 冷启动就不会发生, 所有调用的延迟都将更低

## 外部依赖

-  代码和依赖项一起压缩在一起, 如果小于50 MB，则直接将压缩文件上传到Lambda, 否则先上传到Amazon S3, 然后从Lambda引用
- 原生库：现在Amazon Linux上编译
- AWS SDK：每个 Lambda 自带


## Lambda 和 CloudFormation

- 内联
	- 将在CloudFormation模板中定义Lambda代码
	- 适用于非常简单的函数
	- 使用 ZipFile 属性
	- 不能包含函数依赖项

![](https://mynoteimage.oss-cn-beijing.aliyuncs.com/2023-05-22-153327.png)

- 通过 S3
	- 使用zip文件并通过S3执行此操作
	- 必须在 S3 上存储 zip
	- CloudFormation代码中引用S3的zip位置
	- 建议使用版本控制
		- 因为如果启用了版本控制，覆盖了文件，并指定了新的S3对象版本，CloudFormation将获得更改并更新Lambda函数

![](https://mynoteimage.oss-cn-beijing.aliyuncs.com/2023-05-22-153356.png)


## 容器镜像

- Lambda函数允许部署为ECR中最大10GB映像的容器
- 镜像必须实现Lambda运行时API
- 还允许使用Lambda运行时接口模拟器在本地测试容器


### 最佳实践

- 优化容器镜像
	- 使用AWS提供的基础映像，它已经被  AWS 缓存
- 使用多阶段构建
	- 最终的图像会小得多
- 在不同的图层中构建
	- 图层从稳定到频繁变化
	- 更改最多的事情应该在构建阶段结束时进行
	- 而更改较少的事情, 例如在映像上安装基本包, 应该尽早进行
- 使用单个存储库来存储具有大型层的函数


## Lambda 版本

- $LASTEST，可变
- 创建新的版本后，生成 v1 v2 ... 不可变
- 每个版本都是独立的, 并将获得自己的Amazon资源名称
- 每个lambda函数版本都可以访问, 最新版本也一样

## 别名

- 创建别名，指向一个指定的版本


## 集成 CodeDepoly

- CodeDeploy可以帮助您自动化Lambda别名的流量转移
- 建立在版本和别名之上

- CodeDepoly 策略
	- 线性 ：增长流量每N分钟, 直到100%
		- Linear10PercentEvery3Minutes 
		- Linear10PercentEvery10Minutes
	- 金丝雀：百分比流量
		- Canary10Percent5Minutes
		- Canary10Percent30Minutes
	- AllAtOnce ：立刻切换

### AppSpec.yml

- AppSpec.yml 用来使用 CodeDeploy 部署Lambda
	- Name （必填） : 部署的函数的名称
	- Alias 别名 （必填）：Lambda函数的别名
	- CurrentVersion 当前版本（必填）：流量当前指向的Lambda函数的版本
	- TargetVersion 目标版本（必填）：Lambda函数的版本


## 函数 URL

- 如果只想将Lambda函数公开为HTTP端点，而不必经历使用API Gateway或应用程序平衡器的麻烦
- 函数  URL 提供了你一个唯一的URL端点, 它永远不会改变你的Lambda函数
- 可以通过网络浏览器、命令行、邮差或任何HTTP客户端来执行HTTPS请求
- 支持基于资源策略管理和CORS配置


### 安全

- 基于资源策略
	- 验证账户、指定用户、IAM 规则
- CORS
	- AuthType None ：不允许任何请求
	- AuthType AWS_IAM ：IAM 对 进行身份验证和授权
		- 必须有 lambda：InvokeFunctionUrl 权限
		- 同一个账户中，可以使用身份的策略或基于资源的策略允许此API调用
		- 跨帐户操作，需要同时使用身份策略和基于资源的策略


## 限制

- 限制是在每个区域级别


- 运行
	- 内存分配在128 MB 到10 GB 字节，64 MB 为增量
	- 最长执行时间为900秒, 即15分钟
	- 最多只能有4 KB 的环境变量
	- 临时空间 /tmp 10 GB
	- 执行 1000个 并发操作
- 部署
	- 压缩zip文件的最大大小为 50 MB
	- 未压缩的最大大小为250 MB
	- 大于以上的都应该使用 /tmp


## 最佳实践

- 需要在函数处理程序之外执行繁重的工作, 以最大限度地缩短处理程序的运行时间
	- 意味着您需要在函数处理程序之外连接数据库
	- 再次在处理程序之外初始化AWS SDK
	- 并再次在函数处理程序之外构建任何依赖项或数据集
- 使用环境变量用于任何会随时间变化的内容
	- 数据库连接字符串
	- S3存储桶名称等等
	- 密码和敏感值，使用KMS加密这些环境变量
- 将部署包的大小最小化到其运行时所需的大小
	- 如果你的函数太大, 请把它分解
	- 如果需要重用某些库, 可以考虑利用Lambda层
- 避免递归代码
	- 不要让Lambda函数调用它自己
