### 如何分析排序算法

- 排序算法的执行效率
  
  - 最好情况、最好情况、平均情况复杂度
  
    了解排序算法在不同数据下的性能表现
  
  - 时间复杂度的系数、常数、低阶
  
    数据规模小的时候，同一阶时间复杂度的排序算法 需要考虑
  
  - 比较次数和交换次数
  
    基于比较的算法：比较大小、交换或移动
  
- 排序算法的内存消耗

  原地排序：特指空间复杂度是O(1)的排序算法

- 排序算法的稳定性

  稳定性：待排序的序列中存在值相等的元素，经过排序后，相等元素之间原有的先后顺序不变

### [[#冒泡排序(Bubble Sort)]]

![](https://tva1.sinaimg.cn/large/008i3skNgy1gqmypnisk7j30vq0kldhz.jpg)

特点:
- 原地排序算法
- 稳定排序算法
- 时间复杂度
	- 最好时间复杂度：O(n)
	- 最坏时间复杂度：O(n)2
	- 平均情况复杂度：O(n)2
	

### [[#插入排序]]

核心思想：数据分为两个区间，**已排序**区间和**未排序**区间，取出未排序空间空间到 元素，在已排序的区间中，放到合适的位置，完成排序。

![](https://tva1.sinaimg.cn/large/008i3skNgy1gqmyui3euij30vq0jf408.jpg)

包含**两种操作**：
- 元素的比较
- 元素的交换

特点:
- 原地排序算法
- 稳定排序算法：对于值相同的，将后出现的元素插入到前面已经出现的元素前面。
- 时间复杂度
	- 最好时间复杂度：O(n)
	- 最坏时间复杂度：O(n)2
	- 平均时间复杂度：O(n)2，每次插入操作 = 在数组中插入一个元素

### [[#选择排序]]
![](https://tva1.sinaimg.cn/large/008i3skNgy1gqmz55s7k7j30vq0nsq5g.jpg)


核心思想：分为两个区间，**已排序**区间和**未排序**区间，在未排序区间中找到最小的元素，将其放到已排序区间的末尾

特点：
- 原地排序算法
- 不稳定排序算法
- 时间复杂度 
	- 最好时间复杂度：O(n)
	- 最坏时间复杂度：O(n)2
	- 平均时间复杂度：O(n)2，

### 总结
![](https://tva1.sinaimg.cn/large/008i3skNgy1gqnsopviasj30vq0g840u.jpg)

### [[#归并排序]]
![](https://tva1.sinaimg.cn/large/008i3skNgy1grjbveoeqjj30vq0petc0.jpg)

核心思想：归并排序使用**分治思想**，将一个大问题分解成多个小问题来解决。分治算法一般使用**递归**实现。

``` 
	递推公式： merge_sort(a...z) = merge(merge_sort(a-i), merget_sort(i+1...z))
	
	终止条件：a >= i
``` 

特点：

- 非原地排序算法
- 稳定排序算法
- 时间复杂度
	- 最好时间复杂度：O(nlogn)
	- 最坏时间复杂度：O(nlogn)
	- 平均时间复杂度：O(nlogn)
- **空间复杂度：O(n) **

时间复杂度推导过程：
对于归并，就是将 a 问题拆分为 b、c 两个问题，解决 b、c 问题之后，再将 b、c 结果合并成 a 的结果，可表示为：

```
	T(a) = T(b) + T(c) + k
```

其中，k 为合并 b、c 成 a 的结果所耗费的时间

```
	T(1) = C (T(1) 固定执行次数，为常量)
	T(n) = 2 * T(n/2) + n (n > 1 时的时间复杂度)
	
	
T(n) = 2*T(n/2) + n
     = 2*(2*T(n/4) + n/2) + n = 4*T(n/4) + 2*n
     = 4*(2*T(n/8) + n/4) + 2*n = 8*T(n/8) + 3*n
     = 8*(2*T(n/16) + n/8) + 3*n = 16*T(n/16) + 4*n
     ......
     = 2^k * T(n/2^k) + k * n
     ......
```

通过这样一步一步分解推导，我们可以得到 T(n) = 2^kT(n/2^k)+kn。当 T(n/2^k)=T(1) 时，也就是 n/2^k=1，我们得到 k=log2n 。我们将 k 值代入上面的公式，得到 T(n)=Cn+nlog2n 。如果我们用大 O 标记法来表示的话，T(n) 就等于 O(nlogn)。所以归并排序的时间复杂度是 O(nlogn)。



### 快速排序

核心思想：排序数组下标 p 到 r 直接的数据，选择其中任一数据作为 pivot 分区点。遍历 p-r 之间的数据，将小于 pivot 的数据放在 pivot 数据点的左边，大于 pivot 的数据放在右边。

![](https://tva1.sinaimg.cn/large/008i3skNgy1gqp1c2y401j30vq0h3jsd.jpg)

时间复杂度：O(nlogn)

```	
T(1) = C；   n=1时，只需要常量级的执行时间，所以表示为C。
T(n) = 2*T(n/2) + n； n>1
```

但是达到上述公式的条件，需要每次分区，pivot 都能对等的一分为二，但是很难实现。

根据分治、递归的思想，分别处理 p - q-1 和 q+1 - r 之间的数据，知道区间数据为1或者为0。

```

递归条件：quick_sort(p-r) = quick_sort(p-q-1) + quick_sort(p-q+1);

终止条件：p >= r

```

代码实现：

```
quick_sort(A) {
	// n 为数组大小
	quick_sort_c(A, n);
}

quick_sort_c(A,p,r){
	
	if (p >= r) {
		return;
	}
	
	// 获取分区点
	q = partition(A,p,r);
	quick_sort_c(A,p,q-1);
	quick_sort_c(A,q+1,r);
}


```


### 归并排序 & 快速排序区别

![](https://tva1.sinaimg.cn/large/008i3skNgy1gqp2157a33j30vq0l1ad1.jpg)

- 归并排序：由下往上
- 快速排序：由上往下


### 线性排序
