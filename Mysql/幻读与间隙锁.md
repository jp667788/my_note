
``` mysql
	DROP TABLE IF EXISTS `t`;
	CREATE TABLE `t` (
	  `id` int(11) NOT NULL,
	  `c` int(11) DEFAULT NULL,
	  `d` int(11) DEFAULT NULL,
	  PRIMARY KEY (`id`),
	  KEY `c` (`c`)
	) ENGINE=InnoDB;

	insert into t values(0,0,0),(5,5,5),
	(10,10,10),(15,15,15),(20,20,20),(25,25,25);
```

``` mysql
	begin;
	select * from t where d=5 for update;
	commit;
```

### 当前读如何加锁


#### 假设一：只对 id=5 这一行加锁

![](https://mynoteimage.oss-cn-beijing.aliyuncs.com/note/2021-11-21-075122.jpg)

1. Q1 返回 id=5 这一行
2. Q2 返回 id=0和id=5 两行
3. Q3 返回 id=0、id=1和id=5 三行

Q3 读到 id=1 这一行的现象，被称为**幻读**

##### 幻读是什么
幻读指**是一个事务在前后两次查询同一个范围时，后一次查询查到前一次查询没有看到的行**
- 幻读只针对可重复读隔离级别（RR），普通查询为快照读，不会看到其他事务看到的数据，只有[[Mysql 事务#当前读]]才会发生
- 幻读只针对新插入的行，更新的行不属于幻读（属于不可重复读）

##### 幻读的问题

###### 对当前读加锁的语义破坏：

![](https://mynoteimage.oss-cn-beijing.aliyuncs.com/note/2021-11-21-082755.jpg)

T1 时刻 Q1语义：把所有 d=5 锁住，不准别的事务进行读写操作
T2 时刻 session B  和 Session C 都产生了新的 d=5的记录，**破坏了 sessionA 中的加锁语义**

###### 数据一致性问题

锁设计就是为了保证数据一致性，不仅要保证数据库内部数据的一致性，还要保证数据和日志在逻辑上的一致性。

![](https://mynoteimage.oss-cn-beijing.aliyuncs.com/note/2021-11-21-085950.jpg)

数据库执行：
1. T1：id=5 这一行变成了(5,5,100)，Session A 事务未提交
2. T2：id=0 变成 (0,5,5)
3. T3：session A 查询到 id=0（0,5,5） 这一行数据
4. T4：新增 (1,1,5) 一行数据，更新为 (1,5,5)
5. T5：session A 查询到 id=0（0,5,5）和 id=1 （1,5,5）两行数据

binlog 数据：
1. T2：session B 事务提交，写入两条语句
2. T4：session C 事务提交，写入两条语句
3. T6：session A 事务提交，写入 update 语句

binlog 大致如下：
``` mysql
update t set d=5 where id=0; /*(0,0,5)*/
update t set c=5 where id=0; /*(0,5,5)*/

insert into t values(1,1,5); /*(1,1,5)*/
update t set c=5 where id=1; /*(1,5,5)*/

update t set d=100 where d=5;/*所有d=5的行，d改成100*/
```

如果使用 binlog 会产生三行 d=100 的语句：（0,5,100）,（1,5,100）,（5,5,100）


#### 假设二：扫描过程中的行，都加上写锁

![](https://mynoteimage.oss-cn-beijing.aliyuncs.com/note/2021-11-21-085326.jpg)


1. T1 时刻，t 表上 d 列无索引，所以需要全表扫描。此时 Session A 对所有行都加上了写锁
2. T2 时刻，Session B 更新 d=5 需要获取 MDL 写锁，被阻塞
3. T4 时刻， 新增记录不需要获取行锁，不会被阻塞
4. T6 时刻， Session A 提交事务，Session B 继续执行 update 语句

binlog：
1. session C 最先提交，insert 语句和 Update 语句
2. Session A 提交，update 语句
3. Session B 提交，两条 Update 语句

``` mysql
insert into t values(1,1,5); /*(1,1,5)*/
update t set c=5 where id=1; /*(1,5,5)*/

update t set d=100 where d=5;/*所有d=5的行，d改成100*/

update t set d=5 where id=0; /*(0,0,5)*/
update t set c=5 where id=0; /*(0,5,5)*/
```

根据 binlog，得到  （0,5,5），（1,5,100），(5,5,100) 三行数据

如果对扫描中的所有行加锁：id=0 数据一致性已经没有问题，但是 id=1 新增的这一行，数据库中的数据为（1,5,5），而 Binlog 中为 (1,5,100)

因为id =1，是不存在的一行，不会被加上行锁。**即使给所有行都加上了锁，但是阻止不了新插入的记录**

#### 产生幻读的原因
行锁只能锁住行，但是新插入记录的这个动作，要更新的是记录之间的间隙，所以需要引入[[#间隙锁 Gap Lock]]

### 间隙锁 Gap Lock

间隙锁锁的是两个值之间的间隙

![](https://mynoteimage.oss-cn-beijing.aliyuncs.com/note/2021-11-21-090855.jpg)

当执行 select * from t where d=5 for update 时，不仅给所有扫描行的记录加上了行锁，还同时加了 7个间隙锁，确保无法插入新的记录

**间隙锁与间隙锁之间不存在互斥，间隙锁只互斥 往当前间隙中插入记录的操作**

![](![[Pasted image 20211121171231.png]])

1. Session A 查询 c=7 这一行，由于不存在，会加上间隙锁 (5, 10)
2. Sessoin B 也查询 c=7，也会加上间隙锁 (5,10)，但是不会因为 session A 已经加上了间隙锁而被阻塞

#### next-key lock
间隙锁和行锁合成 next-key lock，是前开后闭区间。
在执行 select * from t where d=5 for update 时，会形成 7 个 next-key lock：
分别是 (-∞,0]、(0,5]、(5,10]、(10,15]、(15,20]、(20, 25]、(25, +supremum]

> supremum：InnoDB 给每个索引加了一个不存在的最大值 supremum

#### next-key lock 死锁

``` mysql

begin;
select * from t where id=N for update;

/*如果行不存在*/
insert into t values(N,N,N);
/*如果行存在*/
update t set d=N set id=N;

commit;
```

在并发情况下，可能会发生死锁：

![](https://mynoteimage.oss-cn-beijing.aliyuncs.com/note/2021-11-21-091907.jpg)

1. session A 加上了 7 个 next-key lock
2. session B 也加了 7 个 next-key lock，并插入 id=9的记录，此时被 session A 的间隙锁阻塞
3. session A 插入 id=9 的记录，被 session B 的间隙锁阻塞，产生死锁

**间隙锁的引入，可能导致同样的语句锁住更大的范围，一定程度上影响了并发度**

### 幻读其他解决办法
由于幻读只在可重复隔离级别下，间隙锁在可重复读隔离级别下才会生效。
在读已提交的隔离级别下，不会有间隙锁，但是需要解决数据和日志不一致的问题。
可以将 binlog 设置为 row 模式，row 模式下 记录的是每一行数据的修改（记录id=xxx的修改）
> 举例： 删除 statement记录的是这个删除的语句，例如： delete from t where age>10 and modified_time<='2020-03-04' limit 1 而row格式记录的是实际受影响的数据是真实删除行的主键id，例如： delete from t where id=3 and age=12 and modified_time='2020-03-05'


### 加锁对象
访问到的对象才会加锁，这个“对象”指的是列，不是 记录行。 
 **加锁，是加在索引上的。 列上，有索引，就加在索引上； 列上，没有索引，就加在主键上**；

### **加锁规则**
1. 原则1：加锁的基本单位是 next-key lock，前开后闭区间
2. 原则2：查询过程中访问到的对象才会加锁
3. 优化1：索引上的等值查询，唯一索引加锁时， next-key lock 会被退化为行锁
4. 优化2：索引上的等值查询，向右遍历且最后一个值不满足等值条件的时候，next-key lock 退化为间隙锁
5. 一个 bug：唯一索引的范围查询会访问到不满足条件的第一个值为止




建表语句: 
``` mysql

CREATE TABLE `t` (
  `id` int(11) NOT NULL,
  `c` int(11) DEFAULT NULL,
  `d` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `c` (`c`)
) ENGINE=InnoDB;

insert into t values(0,0,0),(5,5,5),
(10,10,10),(15,15,15),(20,20,20),(25,25,25);
```

#### 等值查询间隙锁
![](https://mynoteimage.oss-cn-beijing.aliyuncs.com/note/2021-11-21-100105.jpg)

1. 由于 id=7 不存在，无法加行锁，所以不满足原则2。根据原则1，session A 加锁范围是 （5，10]
2. 根据优化2，这是等值查询，且下一个值 id=10不满足，退化为间隙锁

#### 非唯一索引等值锁
![](https://mynoteimage.oss-cn-beijing.aliyuncs.com/note/2021-11-21-100913.jpg)

1. 根据原则1，在索引 c 上加了 (5,10] 的 next-key lock
2. 根据优化2，索引 c 非唯一索引需要往下遍历，且最后一个值不满足，退化为 (5,10) 间隙锁
3. 根据原则2，只有访问到的对象才会加锁。session A 由于覆盖索引，只对索引 C 加锁，session B 获取的是主键索引锁，不会被 block
4. session C 插入的数据需要获取 索引 C 的锁，会被 block

但是如果是 for update ，系统会认为你接下来要更新数据，会给主键索引也加上锁

#### 主键索引范围锁
``` mysql 

mysql> select * from t where id=10 for update;
mysql> select * from t where id>=10 and id<11 for update;

```

上面两条语句在加锁范围并不相同，即使 id 是 int 类型
 
 ![](https://mynoteimage.oss-cn-beijing.aliyuncs.com/note/2021-11-21-105645.jpg)
 
 session A 加锁：
 1. id =10 这一行，本来应该是加 next-key lock (5, 10]，由于是主键索引，根据优化1，退化为 id=10 这一行的行锁
 2. 由于是范围查找，找到 id = 15 停下来，所以加 next-key lock (10, 15]

所以 session A 加的锁： 行锁 id =10 和 next-key lock  (10, 15]

#### 非唯一索引范围锁

![](https://mynoteimage.oss-cn-beijing.aliyuncs.com/note/2021-11-28-061437.jpg)

1. Session A 查询非唯一索引c，满足条件 c=10 的第一个记录，加 (5,10] next-key lock。由于是**非唯一索引，不会退化成行锁。** 
2. Session B 被 block
3. Session A c<11 条件，一直查询到第一个不满足的记录，即 c=15，加（10,15] next-key block。由于是**范围查询，非唯一索引范围查询不会退化成间隙锁。 **

#### 唯一索引范围锁的 Bug （Mysql 8.0.20 后应该不会出现）
![](https://mynoteimage.oss-cn-beijing.aliyuncs.com/note/2021-11-28-061958.jpg)

1. Session A 进行范围查询，id=10 不满足条件，从id=10后面的记录一直查询到 id=15，加 (10,15] next-key lock
2. **【bug】** 虽然id是唯一索引，但是 mysql 在 id=15这一行依旧会继续往下查，一直到第一个不满足条件的记录，即 id =20，加(15,20] next-key lock。


#### 非唯一索引存在等值
表 t 中添加一条数据：

``` mysql
insert into t values(30,10,30);
```

这个时候，索引 c 上有两个 c=10 的记录：
![](https://mynoteimage.oss-cn-beijing.aliyuncs.com/note/2021-11-28-063229.png)

两个 c=10 的记录对应的 不同的id，(c=10,id=10) 和 (c=10,id=30)

执行下面操作：

![](https://mynoteimage.oss-cn-beijing.aliyuncs.com/note/2021-11-28-063403.jpg)

> delete 与 for update 效果一致

1. Session A 查询 c=10 的记录，加 (5,10] next-key lock。
2. 由于是非唯一索引，继续遍历下一个记录直到不满足条件。即遍历到 c=15。加(10,15]。
3. 根据优化2，由于是等值查询，c=15 不满足条件，退化为 (10,15)。
4. Session A 在 c 索引上持有一个(5,10] next-key lock 和 一个  (10,15) 间隙锁
5. Session A 在 主键索引上 持有 id=10 和 id=30 的行锁

#### limit 语句加锁
数据同上个案例。

![](https://mynoteimage.oss-cn-beijing.aliyuncs.com/note/2021-11-28-070025.jpg)


1. Session A 查询第一个 c=10的值，接着往后遍历.
2. 由于 c=10 正好只有两条记录，遍历到第二个 c=10后就停止遍历。所以加锁 (5,10] next-key lock ，即加锁 (c=5, id=5) 到 (c=10 id=30) 范围。
3. 因此不会 block c=12 的 insert 操作

![](https://mynoteimage.oss-cn-beijing.aliyuncs.com/note/2021-11-28-072321.png)

#### 一个死锁的例子

[[#next-key lock]] 是由一个间隙锁加行锁组成的，所以**整个 next-key lock 的加锁动作也要氛围两个阶段：1. 间隙锁加锁 2. 行锁加锁**

![](https://mynoteimage.oss-cn-beijing.aliyuncs.com/note/2021-11-28-073054.jpg)

1. Session A 加锁：(5,10] -> 非唯一索引继续遍历：（10,15] -> 等值查询，优化2 ->(10,15)。最后加锁：(5,10]，(10,15)
2. Session B 加间隙锁 (5,10) 成功，**间隙锁之间不互斥**。再请求c=10 行锁时失败，blocked
3. Session A 添加 c=8 记录，被 Session B当前获取的间隙锁 block 死锁。

session B 是在获取行锁时被阻塞，而不是 next-key lock。next-key lock 是两阶段加锁。
