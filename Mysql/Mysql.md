- Mysql
	- 基本知识
		- [[Mysql 基本架构]]
			- 基本组成
				- 连接器
				- 查询缓存
				- 分析器
				- 优化器
				- 执行器
			- 服务层
				- 核心服务功能，以及所有的内置函数
			- 存储引擎层
				- 负责数据的提取和存储
			- 存储引擎
				- InnoDB
					- Mysql 默认引擎
					- 支持事务
					- MVCC
				- MyISAM
					- 数据以紧密格式存储
					- 不支持事务
				- InnoDB VS MyISAM
					- 事务：InnoDB 支持事务
					- 并发：MyISAM 只支持表级锁，InnoDB 支持行级锁
					- 外键：InnoDB 支持外键
	- 索引 [[Mysql 索引]]
		- 索引类型
			- Hash 索引
				- 优点：等值查询
				- 缺点：不支持范围查询（范围查询低效）
			- 有序数组
				- 优点：等值查询、范围查询都支持
				- 缺点：增删效率低下，只适合静态数据
			- 二叉树
				- 优点：有序、支持范围查询
				- 缺点：数据量大，树高会非常高，占用大量空间
			- B+ 树索引
				- 优点：B树一个节点可以存放多个元素，这样B树的树高就会降低。B+树相较于B树，叶子节点会冗余。
				- B树中一个节点为一页活页的倍数最为合适
					- 如果一个节点的大小小于1页，读取这个节点的时候其实也会读出1页，造成资源的浪费
					- 如果大于1页。读取这个节点的时候也会读出2页，造成资源的浪费。
			- 存储结构
				- 基本存储结构：页
					- 各个数据页都会形成一个双向链表
					- 每个数据页中的记录可以组成一个单项链表
					- 每个数据页会为其中的记录生成一个**页目录**，通过主键查找时，会使用**二分查找法**快速定位。
					- 使用非主键作为搜索条件时，只能从最小记录开始依次遍历**单链表中的每条记录**

		- 索引优点 [[Mysql 索引#索引的优点]]
			- 大大减少了服务器扫描行数
			- 避免排序和分组和创建临时表。B+ Tree 索引是有序的，可以用于 ORDER BY 和  GROUP BY 操作。临时表会在排序和分组过程中创建。
			- 将随机IO 变成了顺序IO，索引香玲数据会存储在一起
		- 索引使用条件 [[Mysql 索引#索引的使用条件]]
			-   对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效；
			-   对于中到大型的表，索引就非常有效；
			-   但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。
		- 回表
				- 回到主键索引树搜索的过程，称为**回表** [[Mysql 索引#回表]]
		- 避免回表
				- 覆盖索引 [[Mysql 索引#覆盖索引]]
			- 最左匹配原则 [[Mysql 索引#最左前缀原则]]
		- 如何建立合适的索引
			- 最左匹配原则（范围查询中非常好用）
			- 选择区分度高的索引
			- 索引不能参与计算 （B+数中的村塾都是数据表中的字段值）
			- 尽量扩展索引
		- 字符串建立索引
			- 

		- 查询性能优化
			- 通过 explain 查看自己sql执行情况[[Mysql 索引#EXPLAIN]]
				- select_type
					- SIMPLE：简单查询
					- UNION：联合查询
					- SUBQUERY：子查询
				- table
					- 查询的表
				- possbile_keys
					- 可选择的索引
				- key
					- 实际使用的索引
				- rows
					- 扫描行数
				- type
					- 索引查询类型
						- const：使用主键或唯一索引查询事，只有一行匹配
						- eq_ref：在联接查询汇总，使用主键或唯一索引职匹配到一行
						- ref：使用非唯一索引
						- range：使用主键、单个字段的辅助索引、多个字段的辅助索引的最后一个字段进行范围查询
						- index：索引树全扫描
						- all：全表扫描
			- 使用[[Mysql 索引#覆盖索引]]，减少[[Mysql 索引#回表]]
			- 考虑组建联合索引，利用[[Mysql 索引#最左前缀原则]]
			- 对索引进行函数计算或者表达式计算会使索引失效
			- 利用子查询优化超多分页，limit offset,n 会查询 offset+n 条数据。子查询n调数据再用
			- ![](https://mynoteimage.oss-cn-beijing.aliyuncs.com/note/2021-10-13-100355.jpg)
	- 事务 [[Mysql 事务]]
		- ACID
			- Atomicity 原子性
			- Consistency 一致性
			- Isolation 隔离性
			- Durability 持久性
		- 隔离级别
			- 未提交读 Read UNCOMMITED
			- 已提交读 Read COMMITED
			- 可重复读 Read REPEATABLE
			- 串行化 SERIALIZABLE
		- 锁
			- 共享锁：允许事务读一行数据
			- 排他锁：允许事务删除或更新一行数据
			- 意向共享锁：事务想要获得一张表的某几行的共享锁
			- 意向排他锁：事务想要获得一张表的某几行排他锁
		- MVCC
			- 基础概念
				- 版本号
					- 系统版本号：一个递增的数字。没开始一个事务，系统版本号递增
					- 事务版本号：事务开始时的系统版本号
				- 隐藏的列
					- MVCC 在每行记录后面都保存两个隐藏的列，存储两个版本号
						- 创建版本号：指示创建一个数据行的快照时的系统版本号
						- 删除版本号：如果该快照的杀菌除版本号大于当前事务版本，标识该快照有效，否则该快照已经被删除
			- 实现事务隔离
				- [[Mysql 事务#一致性读]]
				- [[Mysql 事务#当前读]]
				- [[Mysql 锁#两阶段锁协议]]
	- [[Change Buffer]]
	- Mysql 死锁解决
		- 合理的设计索引，区分度高的列放到组合索引前面，使业务 SQL 尽可能通过索引**定位更少的行，减少锁竞争**。
		- 调整业务逻辑 SQL 执行顺序， 避免 update/delete 长时间持有锁的 SQL 在事务前面。
		- 避免**大事务**，尽量将大事务拆成多个小事务来处理，小事务发生锁冲突的几率也更小。
		- 以**固定的顺序**访问表和行。比如两个更新数据的事务，事务 A 更新数据的顺序为 1，2;事务 B 更新数据的顺序为 2，1。这样更可能会造成死锁。
		- 在并发比较高的系统中，不要显式加锁，特别是是在事务里显式加锁。如 select … for update 语句，如果是在事务里 **（运行了 start transaction 或设置了autocommit 等于0）**,那么就会锁定所查找到的记录。
		- 尽量按**主键/索引**去查找记录，范围查找增加了锁冲突的可能性，也不要利用数据库做一些额外额度计算工作。比如有的程序会用到 “select … where … order by rand();”这样的语句，由于类似这样的语句用不到索引，因此将导致整个表的数据都被锁住。
		- 优化 SQL 和表设计，减少同时占用太多资源的情况。比如说，**减少连接的表**，将复杂 SQL **分解**为多个简单的 SQL。
