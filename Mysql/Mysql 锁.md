# Mysql 锁
根据枷锁范围分类：
- 全局锁
- 表级锁
- 行级锁

## 全局锁
全局锁就是对整个数据库实例加锁，让整个实例处于只读的状态，
命令：
```
Flush table with read lock (FTWRL)
```
这个命令会使其他线程的以下语句被阻塞：
- 数据更新语句（数据的增删改）
- 数据定义语句（包括建表、修改表结构等）
- 更新类事务的提交语句。

Mysql 提供了 mysqldump 工具，使用参数 -single-transaction 时候，导数据前，会开启事务保证数据的一致性，**但是前提是该引擎支持事务**。

命令：
```
	set global table readonly =true
```

这个命令也可以使数据库处于只读状态，但是一般来说不推荐：
- readonly 可能有其他业务用途，比如判断库是主库还是备库
- 异常处理机制上有差异。FTWRL 命令如果出现异常，会自动释放全局锁。readonly = true 在出现异常后，整个库依然是只读状态。

## 表级锁
Mysql 中表级锁有两种：
- 表锁
- 元数据锁（Meta data lock, MDL）

### 表锁
语法：lock tables t read/write
使用 unlock tables t 主动释放，也可以在客户端断开链接时，自动释放。

lock tables 不仅会限制其他线程，也会限制当前线程的操作。
如：

```
lock tables t1 read, t2 write.
```

当前线程在加锁之后只能做 t1 的读 和 t2 的写，不能有其他操作，也不能访问其他表。

### 元数据锁 MDL
MDL 不需要显示加上，在访问一张表的时候会自动加上，以保证读写的正确性。防止在读写过程时，做表结构的修改，导致读写错误。
- 当对表做增删查改时，加MDL读锁。
- 当对表做表结构修改时，加MDL写锁。
- 读锁不会互斥，允许多个线程同时获取读锁
- 读锁与写锁互斥，
- MDL 到事务结束才会释放


## 两阶段锁协议
在 InnoDB 引擎中，行级锁是需要时才加上，但不是不需要了才释放，要等到事务**提交后才会释放**。这个称为两阶段锁协议。
> 长事务会影响并发度。如果一个事务中需要多个行级锁，建议将最可能造成所冲突的、最可能影响并发度的语句放在最后。

## 死锁与死锁检测
当并发系统出现不同的线程循环资源依赖，线程彼此都在等待对方释放锁，就会形成死锁。
![](https://mynoteimage.oss-cn-beijing.aliyuncs.com/2023-06-29-143225.jpg)

防止死锁的策略：
- 设置锁等待超时时间。通过 innodb_lock_wait_timeout 参数来设置， 默认 50s 
- 主动死锁检测，发现死锁后，主动回滚死锁中的其中一个事务。通过 innodb_deadlock_detect 设置，默认开启




