## 索引常见模型
- 哈希表
	键 - 值（key - value）
	哈希表只适合做等值查询，不适合做区间查询

- 有序数组
	区间查询效率高，更新插入效率慢，只适用于静态数据查询

- 搜索树

## InnoDB 索引模型
B+ 树索引模型
每一个索引在 InnoDB 引擎中都对应一个 B+树


### 索引类型
- 主键索引（聚簇索引 clustered index）
	主键索引的叶子节点保存的整个数据行的数据

- 非主键索引（二级索引 secondary index）
	非主键索引的叶子节点保存主键的值

>  建表语句：
>  ```mysql> 
>  create table T
>  (id int primary key, 
> k int not null, 
> name varchar(16),
> index (k))
> engine=InnoDB; 
>  ```
>  表中 R1~R5 的 (ID,k) 值分别为 (100,1)、(200,2)、(300,3)、(500,5) 和 (600,6)，两棵树的示例示意图如下。
>  
>  ![](https://mynoteimage.oss-cn-beijing.aliyuncs.com/2023-06-29-143045.jpg)


使用主键索引和非主键索引查询的区别：
- 如果是 select *  from T where id = 300 ，此时只需要搜索主键 B+树
- 如果是 select *  from T where k = 5，此时需要先搜索 K索引B+树，找到主键值后，再去主键B+树搜索。**这个过程称为回表**


## Mysql 索引 B+ 树
B+ Tree  是 B Tree 的一种变形，他是基于 B Tree 和 叶子节点顺序访问指针实现。

### 数据结构
B+ 树有两种类型的节点：
- 内部节点，也称索引节点
	- 非叶子节点，不存储数据，只存储索引
	- 内部节点中的 Key 都按照从小到大的顺序排列，切左子树中的所有key走小于该内部节点，右子树中的 Key 都大于等于它。
- 叶子节点
	- 存储数据
	
	
![](https://mynoteimage.oss-cn-beijing.aliyuncs.com/2023-06-29-143109.jpg)

### 操作
- 查找
	
	查找起始于根节点，自顶向下遍历树，选择器分离值在要查找值的任意一边的子指针，使用二分查找
	
- 插入
	- 执行一次查询决定元素需要插入的位置
	- 如果当前节点没有装满（插入后的元素个数< L），直接插入该元素  (L为节点能存储的最大数量)
	- 否则在插入之前：
		- L+1/2）这个节点 
			- （L+1/2）的元素保存在原来的节点
			- 另外（L+1/2）的元素保存在新的节点
		- 移动第 （L+1/2）个元素到父节点中（进位到父节点），讲这个父节点的左指针指向左子节点，右指针指向右子节点
		- 一直到父节点不会重新分裂

- 删除
	- 与插入类型，是自下而上的合并


https://www.cnblogs.com/nullzx/p/8729425.html
- 

## 回表
回到主键索引树搜索的过程，称为回表



### 索引维护
B+树需要维护索引有序性，在插入新值时需要做必要的维护。如果当前数据页满了，还需要重新申请新的数据页，然后挪动部分数据过去，**这个过程称为页分裂**，相反的还有**页合并**

自增主键的插入数据模式，每次插入新数据时都是住家，并不会涉及数据挪动


## 覆盖索引
在搜索非主键索引树时，非主键索引已经覆盖了要查询的内容（索引K 只查询了K字段），此时不需要发生[[#回表]]，称为**覆盖索引**

覆盖索引可以减少树的搜索次数，提升查询效率，是一种常见的[[Mysql 优化]]手段



## 最左前缀原则

> MYSQL做词法分析语法分析的时候是通过建立最左子树来建立语法树的，解析的过程也是从左到右所以遵循最左前缀的原则。

## 索引下推
> 【索引下推】Index Condition Pushdown，简称 ICP。 是Mysql 5.6版本引入的技术优化。旨在 在“仅能利用最左前缀索的场景”下（而不是能利用全部联合索引），对不在最左前缀索引中的其他联合索引字段加以利用——在遍历索引时，就用这些其他字段进行过滤(where条件里的匹配)。过滤会减少遍历索引查出的主键条数，从而减少回表次数，提示整体性能。 ------------------ 如果查询利用到了索引下推ICP技术，在Explain输出的Extra字段中会有“Using index condition”。即代表本次查询会利用到索引，且会利用到索引下推。 ------------------ 索引下推技术的实现——在遍历索引的那一步，由只传入可以利用到的字段值，改成了多传入下推字段值。

索引下推可以在索引遍历的过程中，对索引中包含的字段优先做判断，从而过滤掉不满足条件的记录，减少回表的次数

无索引下推流程
![无索引下推流程](https://mynoteimage.oss-cn-beijing.aliyuncs.com/2023-06-29-143141.jpg)

索引下推流程
![索引下推流程](https://mynoteimage.oss-cn-beijing.aliyuncs.com/2023-06-29-143159.jpg)


## 索引的优点
- 大大减少了服务器扫描行数
- 避免排序和分组和创建临时表。B+ Tree 索引是有序的，可以用于 ORDER BY 和  GROUP BY 操作。临时表会在排序和分组过程中创建。
- 将随机IO 变成了顺序IO，索引香玲数据会存储在一起

## 索引的使用条件
-   对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效；
-   对于中到大型的表，索引就非常有效；
-   但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。

## EXPLAIN
- select_type
	- SIMPLE：简单查询
	- UNION：联合查询
	- SUBQUERY：子查询
- table
	- 查询的表
- possbile_keys
	- 可选择的索引
- key
	- 实际使用的索引
- rows
	- 扫描行数
- type
	- 索引查询类型
		- const：使用主键或唯一索引查询事，只有一行匹配
		- eq_ref：在联接查询汇总，使用主键或唯一索引职匹配到一行
		- ref：使用非唯一索引
		- range：使用主键、单个字段的辅助索引、多个字段的辅助索引的最后一个字段进行范围查询
		- index：索引树全扫描
		- all：全表扫描

## 字符串类型索引

### 前缀索引
使用前缀索引：定义指定长度 的索引

``` mysql
	alter table xxx add index indexxx(xxxIdx(x))
```


#### 前缀索引长度的确定
区分度越高越好：损失区分度在 5% 以下

``` mysql
	
	-- 先查询该字段去重后的数量 total
	select count(distinct xxx) from T
	-- 再查询截取指定长度前缀的数量 c
	select count(distinct left(xxx, x)) from T
	
	-- c / total >= 95% 即可
	
```


指定了索引长度前缀索引会导致系统无法确定是否包含完整的字段信息（即使是超过字段本身的索引长度），所以必须回表查询主键索引的数据进行比对。

- 优点
	- 节省空间，也不额外增加查询成本
- 缺点
	- 无法使用覆盖索引

### 倒序存储
对于身份证号这周前缀相同，可以采用倒序存储

``` mysql
	select field_list form t where id_card = reverse('input_id_card_string')
```

### hash 字段
可以再创建一个新的字段，保存身份证的 hash，再在此字段上建立索引
因为有可能会出现 hash 冲突，索引还需要再加上 id 的判断条件

``` mysql

select field_list from t where id_card_crc=crc32('input_id_card_string') and id_card='input_id_card_string'
```


- 倒序存储不会小号额外的存储空间
- 倒序存储需要额外调用一次 reserve 函数，hash 字段需要额外调用 crc32() 函数。CPU 消耗上，reserve 更小一点
- hash 查询效率高一点，冲突概率小，平均扫描行数接近 1
