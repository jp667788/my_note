## Mysql 事务

事务是保证一组数据库操作，要么全部成功，要么全部失败。
Mysql 的事务支持是在引擎级别支持，不是所有的引擎都支持事务。MyISAM 引擎就不支持事务。

## 事务的特性
ACID ：
- Atomicity  原子性
- Consistency 一致性
- Isolation 隔离性
- Durability 持久性

## 隔离和隔离级别 Isolation
- 脏读	dirty read
- 不可重复读	non-repeatable read
- 幻读	phantom read

隔离级别就是为了解决上面的问题，四个隔离级别：

- 读未提交	read uncommitted
	一个事务没有提交时，它的变更可以被其他事务看到
- 读已提交	read committed
	一个事务只有提交时，它的变更才可以被其他事务看到
- 可重复读	repeatable read
	一个事务执行中看到的数据，总是跟在事务开始时看到的数据是一致的。
- 串行化	serializable
	读写操作都会加锁，锁冲突时，事务需要等待前一个事务完成才能继续执行


**Mysql 默认的事务隔离级别是 可重复读**

可以通过 SET transaction Isolation level 设置隔离级别，新的隔离级别会在下一个事务生效。


## 事务隔离的实现

数据库多版本并发控制 **MVCC**
> MVCC 只在 read committed 和   repeatable read 两个隔离级别下工作

Mysql 在每次更新操作时都会同时记录一条回滚记录，最新的值可以通过回滚操作还原到前一个状态的值。

![](https://tva1.sinaimg.cn/large/008i3skNgy1gt97ywtr08j30vq0khq3s.jpg)

当系统中没有比当前回滚日志还早的视图时，回滚日志就会被删除
> 基于此，尽量不要用长事务，长事务会导致系统里面存在很老的事务视图，长事务还会占用锁资源。


MVCC 的具体操作：
- **SELECT**：InnoDB 会根据下面两个条件查找
	- **只查找比当前版本号早的数据行**。这样确保了，这条数据要么是在事务开始前就已经存在，要么是该事务自己插入或修改
	- **数据行的删除版本要么没有，要么要大于当前查询事务的版本号**。这样可以确保，在这个事务开启之前，这条数据没有被删除
- **INSERT**： 插入的的每一行保存当前系统版本号作为行版本号。
- **DELETE**：删除的每一行保存当前系统版本号作为删除标识
- **UPDATE**：插入一行新纪录作为保存当前系统版本号作为当前行版本号，同时保存当前系统版本号作为原来行的删除标识
- 

## 事务的启动方式

1. 显示的开启事务语句。begin 和 start transaction 代表开始一个事务，commit 提交高事务。
2. set autocommit = 0，这个命令会关掉该线程的自动提交，在执行第一个语句时事务自动开启，一直持续到主动 commit 或 rollback 或 断开连接。

```
// 查询长事务 60s
select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))>60
```

## MVCC 
InnoDB 中每个事务都有一个 transaction Id，事务开始时向事务系统申请，并且**严格递增**。
每个事务在更新一行数据时，都会生成一个新的数据版本，并将该事务的 transaction id 赋值给当前数据版本的事务id，记作 row trx_id。
**数据表中的一行数据，也会有多个版本，每个版本都有自己的 row trx_id**

下图就是一个记录被多个事务连续更新后的状态：

![行状态变更图](https://mynoteimage.oss-cn-beijing.aliyuncs.com/2023-06-29-143010.jpg)

图中三个虚线的箭头，其实就是 undo log， 而 v1，v2，v3 并不是真是物理存在的，而是通过最新版本计算出来的。
> 在 InnoDB 中，MVCC 是通过 undo log 实现的

### 一致性视图
InnoDB 在实现上，会给每个事务创造一个数组，用来保存事务启动的瞬间，当前已经启动了但是还没提交的事务ID。

数组中里面最小的事务ID记作低水位，当前**系统中**已经创建了的最大的事务ID+1 记作高水位。
这个视图和高水位就组成了 **一致性视图（Read View）**


### 数据可见性原则
基于数据的 row trx_id 和 数据一致性视图对比的结果，得到了数据可见性原则。

视图数组会把 row trx_id 分为不同的几种情况：

![](https://tva1.sinaimg.cn/large/008i3skNgy1gtxr26lin2j60rm0ew0th02.jpg)

对于**事务启动瞬间**来说，一个数据的 row trx_id 有下面几种情况：
- 如果落在绿色区域，表示版本已提交或是自己创建的，数据可见
- 如果落在红色区域，表示版本对应的事务还未启动，数据不可见
- 如果落在黄色区域，也就是在数组的范围内（只是范围内，不应一定在数组中）
	- 如果数组中不存在，说明该事务已提交，数据可见
	- 如果数组中粗在，说明该事务未提交，数据不可见

> 上述表示需要注意的是：
> - 所有的事务状态都是针对：**当前事务的启动时的瞬间状态**
> - 数组中的row trx_id 从小到到大排列，但不一定是连续的。因为有些row trx_id 偏小的事务执行较快，已经提交

#### 一致性读
事务A开启事务，在这之后其他事务修改数据，事务A 不论在什么时候查询，都能保持数据一致，称为**一致性读**

一个数据版本，对于一个事务来说，有下面几种情况：
- 版本未提交，不可见
- 版本已提交，在创建事务视图之前提交，可见
- 版本已提交，但是在创建事务视图之后，不可见

### 当前读 
数据**更新**时，必须是先读后写，且只能读当前的值，称为当前读。（此时最新的值）
如果普通的 select 语句加锁，也可以实现当前读：
- select 语句末尾加上 lock in share mode (S 锁 共享锁)
- select 语句末尾加上 for update （X锁 排他锁）


### 可重复读 & 读已提交的实现
可重复读和读已提交的核心都在[[#一致性读]]，在事务执行更新时，只能使用[[#当前读]]，在多个事务同时修改同一条数据时，根据[[Mysql 锁#两阶段锁协议]]，进入所等待。
- 在可重复读下：事务在开启时，就会创建[[#一致性视图]]，之后事务里面的其他查询语句都会共用同一个视图。
- 在读已提交下：在每一个语句执行先都会重新计算一个视图       