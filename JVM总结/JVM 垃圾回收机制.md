-   哪些对象需要回收？
-   什么时候回收？
-   如何回收？



### 垃圾回收发生的位置
- 堆
- 方法区
	- 程序计数器、虚拟机栈、本地方发栈是线程私有的，随线程生灭。
	- 堆和方法区是线程共享的，这些地方的内存都是动态的分配和回收的。


### 判断对象需要回收的方法-- (哪些对象需要回收)
#### 引用计数法（ Reference Counting）

- 描述
	- 引用失效时，计数器值减1。
	- 当被引用时，计数器值加1。
	- 当计数器为0时，表示该对象没有被引用，可以被回收。
- 优点
	- 实现简单
	- 效率高
- 缺点
	- 难以解决对象间相互循环利用的问题


#### 可达性分析算法（Reachability Analysis）
- 描述
	- 从GCRoots起始点开始向下搜索，当一个对象到达GCRoots没有任何引用链相连，即从GCRoots到此对象不可达，则该对象不可用。
- GCRoots对象
	- 虚拟机栈（栈帧中的本地变量表）中引用的对象
	- 方法区中类静态属性引用的对象
	- 方法区中常量引用的对象
	- 本地方法栈中JNI（Native方法）引用的对象
	- Java 虚拟机内部的引用 (Class 对象，常驻异常对象，系统类加载器)
	- 所有被同步锁  关键字持有的对象
	- 反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。


### 对象的引用
- 强引用（Strong Reference
	- 类似Object obj = new Object()，只要强引用存在，垃圾回收器永远不会回收该对象

- 软引用（Soft Reference）
	- 描述一些还有用但非必需的对象。系统将要发生内存溢出之前，将这些对象列入回收范围，进行第二次回收。
	- 如果第二次回收后依然没有足够的内存，将会发生内存溢出异常。

- 弱引用（Weak Reference）
	- 描述一些非必需的对象。这些对象只能存活在下次垃圾回收之前，不论内存是否充足，下次垃圾回收器都会回收这些对象。

- 虚引用（Phantom Reference）
	- 幽灵引用或幻影引用。
	- 对象是否存在虚引用，完全不会对其生存时间影响。
	- 无法通过虚引用获得对象实例。
	- 设置虚引用，该对象被回收时收到一个系统通知。
		- 需要设置一个队列，可以监控队列
	- 管理对外内存

### 对象的死亡  -- (什么时候回收)
如果对象经过可达性分析之后没有与GCRoot相连的引用链，如果需要执行finalize()方法的对象，至少需要经历**两次标记**过程.
> 《深入理解Java虚拟机》原文：即使在可达性分析算法中不可达的对象，也并                非是“非死不可”的，这个时候他们暂时处于“缓刑”阶段，要真正宣告一个对象的死亡，至少需要经历两次标记过程。加粗部分我认为可能会有歧义，所以用了我自己容易理解的说法。

#### 两次标记
- 第一次标记：可达性分析之后，发现没有与 GC Roots 相连接的引用链，随后进行筛选出没有必要执行 finalize() 方法的对象：
	- 当前对象没有覆盖finalize()方法
	- finalize()方法被虚拟机调用过
- 第二次标记：如果有必要执行 finalize() 方法
	- 该对象放入 F-Queue 队列中，随后由 Finalizer 线程去执行 finalize() 方法
	- 如果该对象重新被引用，将会被移除“即将回收”的集合。否则，一定会被回收。

>   关于finalize()方法和F-Queue队列:
> 1.  F-Queue中的finalize()方法由虚拟机建立且优先级很低的Finalizer线程执行。
> 2.  虚拟不会保证该线程执行完成，因为可能对象的finalize()方法执行时间太长，导致内存回收系统崩溃。
> 3. finalize()方法是对象最后拯救自己，不被回收的机会。
> 4. 对象想要不被回收，只要重新与引用链上任何一个对象建立关联即可
> 5. finalize()方法只会被系统调用一次。


### 方法区的对象回收
- 特点
	- 方法区的垃圾收集效率很低。在新生代中，一次垃圾收集可以回收70% 至 99% 的内存空间。
	- Java 虚拟机规范可以不要求虚拟机在方法区中实现垃圾收集

- 回收内容
	- 废弃的常量
		- 已经没有任何字符串对象引用常量池中的常量，且虚拟机中也没有其他地方引用该常量
	- 不在使用的类型

- 回收条件， 需要**同时**满足一下条件：
	- 该类所有实例都已经被回收。
	- 加载该类的ClassLoader已经被回收
	- 该类对应的java.lang.class对象没有在任何地方引用，无法在任何地方通过反射访问该类的方法。
	
	满足以上三个条件并不是一定会被回收，虚拟机提供了Xnoclassgc进行控制
	
### 垃圾收集算法 -- (如何回收)
#### 标记-清除 (CMS)
- 两个阶段
	- 标记
		- 记出所有需要回收的对象
	- 清除
		- 标记完成后统一回收所有被标记的对象
- 缺点
	- 效率低
		- 如果堆中有大量对象，且大部分对象需要被回收，就必须进行大量的标记清除动作
		- 浪费空间
			- 标记清除后会出现大量的不连续的内存碎片，导致无法分配内存较大的对象从而再一次触发垃圾回收。

#### 标记-复制算法 (Serial、ParNew)
- 过程
	- 将可用内存按容量分为大小先相同的内存块，每次只使用期其中的一块。当这一块内存用完时，将所有存活的对象都复制到另一块，然后清空已使用的内存。
- 缺点
	- 将内存缩小至原来的一半，代价太高
	- 存活的对象过多时，复制的时间长、效率低。

##### 虚拟机的新生代回收采用复制算法
- 新生代对象很快就会死亡，所以不需要按照1:1比例划分内存
- 虚拟机将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor空间
- 回收时，将Eden和其中一块的Survivor中存活的对象，复制到另一块Survivor空间。
- HotSpot虚拟机默认Eden和Survior的大小为8:1.
- 复制到另一块Survivor时，如果空间不够，需要其他内存（老年代）进行分配担保。（进入老年代）

#### 标记-整理 （Parallel Scavenge）
- 虚拟机的老年代一般采用标记-整理算法
- 老年代可能出现对象100%都存活的极端情况，所以内存必须浪费50%空间。

- 过程
	- 标记-整理算法的标标记过程与标记-清楚算法相同但后续不是直接对可回收对象进行整理，而是让存活的对象都向一端移动
	- 然后直接清除这一端比边界以外的内存
- 缺点
	- 移动对象需要暂停用户应用程序

> 是否移动对象都会存在弊端，移动内存回收过程会更复杂，不移动内存访问会更复杂，影响程序吞吐。但是一般来说，内存访问的频率要比垃圾收集频率高的多。




### 经典垃圾回收器
![](https://mynoteimage.oss-cn-beijing.aliyuncs.com/note/2022-03-19-094403.png)

如果两个收集器之前存在连线，说明它们可以搭配使用。

#### Serial 收集器
- 最基本、历史最悠久的单线程收集器。Serial收集器在虚拟机Client模式下默认的新生代收集器。
- 缺点
	- 它在进行垃圾收集时，必须暂停其他所有工作线程，直到它收集结束。
        
- 优点
	- 简单、高效（与其他单线程的收集器相比）
	- 单核环境下有优势

![](https://mynoteimage.oss-cn-beijing.aliyuncs.com/note/2022-03-19-095032.png)

#### ParNew 收集器
- Serial收集器的多线程版本，其与行为与Serial收集器完全一致。
- 它是虚拟机server模式下首选的新生代收集器
- 它是除了Serial收集器之外唯一能与CMS收集器配合工作的收集器
- ParNew收集器在单线程的环境下的性能并不比Serial收集器要好。

![](https://mynoteimage.oss-cn-beijing.aliyuncs.com/note/2022-03-19-095533.png)

#### Parallel Scavenge 收集器
- 使用标记-复制算法的新生代多线程收集器，也称为“吞吐量优先”收集器。
- 特点
	- 它的目的是达到一个可控制的吞吐量。 吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间)
	- 高吞吐量可以高效率的使用cpu时间，尽快的完成任务，主要是和在后台运算而不需要太多交互的任务。

- 三个参数
	- -XX:MaxGCPauseMills：控制最大垃圾收集停顿时间。允许一个值大于0的毫秒数，收集器尽可能保证收集停顿时间不超过该值。
	- GC停顿时间是以吞吐量和新生代空间来换取的，所以并不是该值越小越好。
	- -XX:GCTimeRadio：设置吞吐量大小。值为0-100的整数，代表垃圾收集时间，占总时间的比率，相当于是吞吐量的倒数。
	- -XX:UseAdapitiveSizePolicy：打开该参数后，GC会采用GC自适应策略，动态调整这些参数以提供合适的停顿时间或者最大的吞吐量。

#### Serial Old 收集器
- 它是Serial收集器的**老年代版本**，**单线程**收集器，使用**标记-整理**算法。

- 用途
	- 虚拟机啊Client模式下使用
	- JDK1.5之前与Parallel Scavenge收集器配合使用。
	- 作为CMS收集器的后备预案

#### Parallel Old 收集器
- Parallel Scavenge 的老年代版本，支持多线程并发收集，基于 标记-整理算法

#### CMS 收集器 （Concurrent Mark Sweep）
- 一种一获取最短回收停顿时间为目标，提高用户体验。
- 基于**标记-清**除算法
    
- 运作过程
	- 初始标记
		- 标记GCRoots能直接关联到的对象，速度很快。**需要停止用户线程**
	- 并发标记
		- 标记可以回收的对象
	- 重新标记
		- 修正并发标记时，因为程序继续运作导致表动的标记记录。**需要停止用户线程**
	- 并发清除
		- 清除被标记可以回收的对象

![](https://mynoteimage.oss-cn-beijing.aliyuncs.com/note/2022-03-19-131736.png)


- 优点
	- 并发收集
	- 低停顿
- 缺点
	- 对CPU资源非常敏感
		-  在并发阶段，虽然不会导致用户线程停顿，但是会占用一部分CPU资源，导致应用程序变慢，总吞吐量降低。
		- CMS 默认线程数 = （处理器核心线程数 + 3） / 4，核心数越多影响越小。
	- 无法处理浮动垃圾
		- 可能出现“Concurrent Mode Failure”失败，而导致另一次Full Gc 的产生。
		- 浮动垃圾：并发清理阶段，用户线程并没有停止，所有依然会有新的垃圾产生，这部分垃圾CMS收集器无法在当次收集时处理。
		- 也正是由于用户线程没有停止，所以CMS收集时，虚拟机需要**预留一部分空间**提供并发收集时的程序运作使用。
		- 如果CMS收集期间预留的内存无法满足程序的需要。就会出现Concurrent Mode Failure失败，虚拟机就会启动后备预案：启用Serial Old 收集器来重新进行老年代的垃圾收集，这就导致了停顿时间很长。

#### Garbage First 收集器
- 基于 Region 的堆内存布局
- G1 不在坚持固定大小及固定数量的分代区域划分
	- 将连续的 Java 堆划分为多个大小相等的**独立区域 （Region）**
	- 每个 Region 根据需要扮演新生代的 Eden 、Survivor 或老年代空间
	- 收集器对不同角色的 Region 采用不同的策略处理
	- Region 中有特殊的 **Humongous** 区域，存储大对象，超过 Region 一半容量的对象称为大对象
- G1 保留新生代和老年代的概念，只是不再固定
- G1 以 Region 作为最小回收单元，即每次收集的都是 Region 大小整数倍的内存空间


- Region
	- G1 收集器追踪各个 Region 里面的垃圾堆积的”价值“大小，即回收所获得的空间大小以及回收所需时间的经验值
	- 在后台维护一个优先级列表
	- 根据设定允许的收集停顿时间（-XX: MaxGCPauseMillis，默认200ms）
	- 优先处理回收价值收益最大的 Region
	
##### Region 需要处理的问题
1. 将Java堆分成多个独立Region后，Region里面存在的**跨Region引用对象如何解决**?
	- 它的每个Region都维护有自己的记忆集，这些记忆集会记录下别的Region 指向自己的指针，并标记这些指针分别在哪些卡页的范围之内。
	- G1的记忆集在存储结构的本质上是一 种哈希表，Key是别的Region的起始地址，Value是一个集合，里面存储的元素是卡表的索引号。
	- 这 种“双向”的卡表结构（卡表是“我指向谁”，这种结构还记录了“谁指向我”）比原来的卡表实现起来更 复杂，同时由于Region数量比传统收集器的分代数量明显要多得多
	- 因此G1收集器要比其他的传统垃 圾收集器有着更高的内存占用负担。

2. 在并发标记阶段如何保证收集线程与用户线程互不干扰地运行？
	- CMS 采用增量更新算法，**G1 使用原始快照（SATB）**
	- G1 在每个 Region 设置了两个名为 TAMS 指针，将 Region 中的一部分空间划分用于并发回收中创建的新对象，新对象必须创建在这个两个位置以上
	- G1 默认在这个地址以上的独一香都是隐式标记过的，即默认存活的
	- 如果内存回收速度赶不上内存分配的速度，会冻结用户线程，进行 FullGC

3. 怎样建立起可靠的停顿预测模型
	- 用户通过 -XX: MaxGCPauseMillis 参数指定的停顿时间，只是一个期望值
	- G1 在回收过程中会记录每个 Region 的回收耗时、每个 Region 记忆集里的张卡数量

	
	
	- 四个阶段
		- 初始标记
			- 标记 GC  Roots 直接关联到的对象，并修改 TAMS 指针的值
			- 这个阶段会借用 Minor GC 时同步完成，实际上没有额外的停顿
		- 并发标记
			- 从 GC Root 开始对堆中对象进行可达性分析
			- 耗时较长，并发执行
			- 重新处理 SATB 下并发时有引用变动的对象
		- 最终标记
			- 用户线程短暂暂停，处理并发阶段遗留的少量 STAB 记录
		- 筛选回收
			- 更新 Region 数据，对各个 Region 进行优先级排序，根据用户设定的停顿时间
			- 自由选择任意多个 Region 构成回收集
			- 把决定会回收那一部分 Region 的存活对象复制到空的 Region 中，再清理整个就的 Region 空间（标记-复制）
			- 这里必须**暂停用户线程**，多条收集器线程并行完成

![](https://mynoteimage.oss-cn-beijing.aliyuncs.com/note/2022-03-20-084030.png)



### 内存分配与回收策略
- 对象优先在 Eden 分配
	- 大多数情况下，对象在 Eden 区分配
	- Eden 去没有足够空间时 发起一次Minor GC 
	- Minor GC 后，如果 Survivor 能容纳，则被移动到 Survivor 中
- 大对象直接进入老年代
	- 避免 Eden 区 以及 两个 Survivor 区来回复制
	- 　-XX：PretenureSizeThreshold参数控制大对象大小
	- 　-XX：PretenureSizeThreshold参数只对Serial和ParNew两款新生代收集器有效
- 长期存活的对象进入老年代
	- 虚拟机给每个对象定义了一个年龄集水器，存储在对象头中
	- 对象移动到 Survivor 后，没经过一次 Minor GC 且存活，age 增加一岁
	- 当 age 达到一定程度 (默认 15 -XX:MaxTenuringThreshold)，就会被晋升到老年代
	- 如果 Suvivor 空间相同年龄所有对象大小的总和 大于 Survivor 空间的一般，年龄大于或等于该年龄的对象就可以直接进入老年代
- 在发生 Minor GC 前，虚拟机必须检查老年代最大可用的连续空间是否大于新生代所有对象总空间
	- 如果成立，则此次 Minor GC 安全
	- 否则，检查 XX：HandlePromotionFailure 是否允许担保失败
		- 允许，继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小（赌）
			- 大于，尝试一次 Minor GC
			- 小于，Full GC
		- 不允许。Full GC