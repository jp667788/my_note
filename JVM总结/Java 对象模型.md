### 对象的创建
- JVM 接受一条字节码 new 指令
- 检查这个指令参数能否在常量池中定位到一个类的符号引用
- 检查这个符号引用代表的类是否已被加载、解析、初始化
	- 如果没，有需要先执行[[JVM 类加载]] 步骤
- 为对象分配内存
	- 如何划分空间
		- 如果内存绝对规整，只需要移动分界点指针（**指针碰撞** Serial ParNew）
		- 如果内存不规整，虚拟机需维护一个列表，记录哪些内存可用（CMS）
	- 如何保证线程安全
		- 同步处理，使用 CAS + 重试
		- 把内存分配的动作按照线程划分在不同的空间中进行。线程中预分配一小块内存，即**本地线程缓冲（Thread Local Allocation Buffer TLAB）**，只有本地线程缓冲用完了，分配新的缓存区才需要同步处理。 -XX: +/-UserTLAB 设定
- 将分配的内存空间（不包括对象头）初始化为零值，使用TLAB时，在 TLAB 分配时同时执行。这样时的Java 代码不赋初始值就可以直接使用
- 对对象进行必要的设置
	- 这个对象是哪个类的实例
	- 如何才能找到类的元数据信息
	- 对象的 hash 码（会延后到真正调用 Object.hashCode() 时继续算）
	- 对象 GC 分代年龄等信息

从虚拟机角度看，一个新的对象已经产生。但是从 Java 程序角度，对象才准备开始执行构造函数，即 Class 文件中的\<init\>() 方法还没有执行。

### 对象的内存布局
对象在堆内存中的存储布局分为：
- 对象头 （Header）
	- Mark Word
	- 类型指针
	- 记录数组长度的数据（如果是数组）
- 实例数据 （Instance Data）
	- 对象信息
		- 父类字段
		- 子类字段
- 对其填充 （Padding）
	- 占位符作用
	- 任何对象大小必须是8个字节的倍数

#### Mark Word
用于存储对象自身的运行时数据
- 哈希码 hashCode
- GC 分代年龄
- 锁状态标志
- 线程持有的锁
- 偏向线程 ID
- 偏向时间戳等

Mark Word 被设计成有着**动态定义**的数据结构
32 位 虚拟机中：

| HashCode | GC 分代年龄 | 锁标志位 | 固定为0 |
|-|-|-|-|
| 25bit | 4 bit | 2 bit | 1 bit |

| 存储内容 | 标志位 | 状态 |
|-|-|-|
|对象 HashCode、对象分代年龄|01|无锁|
|指向锁记录的指针|00|轻量级锁定|
|指向重量级锁的指针|10|膨胀（重量级锁定）|
|空|11|GC 标记|
|偏向线程 ID、偏向时间戳、对象分代年龄|01|可偏向|

#### 类型指针
对象指向他的类型元数据的指针，JVM 通过这个指针是确定是哪个类的实例。

### 对象的访问定位
Java 程序会通过栈上的 reference 数据操作堆上的具体对象，主流的访问方式有两种：
- 句柄访问：堆中可能划出一块内存作为句柄池，
	- reference 中存储的就是对象的句柄地址
	- 句柄包含
		- 对象实例数据
		- 类型数据具体的地址信息
	- 优点
		- 对象被动时，reference 不需要修改，而是修改句柄中的数据
- 指针访问：堆中须考虑如何防止访问类型数据的相关信息
	- reference 存储的是对象地址
	- 优点
		- 访问速度快

![](https://mynoteimage.oss-cn-beijing.aliyuncs.com/note/2022-03-17-153656.png)

![](https://mynoteimage.oss-cn-beijing.aliyuncs.com/note/2022-03-17-153712.png)